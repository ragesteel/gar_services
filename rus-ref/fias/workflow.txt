Процесс получения базы в MySQL из исходного xml-файла (для полного дампа, без дельт)

* Чтение xml из файла; (jaxb, будет модицифироваться)
* Преобразование в java-классы; (jaxb)
* Валидация (bean validation);
* Преобразование в csv; (собственные классы)
* Запись в выходной файл;
* Сортировка; (sort)
* Загрузка с помощью load data infile; (sql)

Понятно что такой путь совсем не оптимален, т.к. у нас используются три отдельных программы.
Есть мысль построить pipeline из двух основных частей:

* Преобразование из xml в набор отсортированных файлов, два буфера для записи/сортировки;
** Поток готовых записей из xml (jaxb + дополнительная логика + bean validation);
** Запись в буфер, как только заполняется переключаемся на второй буфер а первый сортируем и потом записываем;

* Объединение всех промежуточных файлов;
** Читаем сразу изо всех промежуточных файлов;
** Пишем в нужном порядке в выходной csv или сразу в базу;

Для первой части можно сделать несколько потоков:
* Чтения данных и записи в очередь;
* Чтения очереди и запись в буфер;
* Сортировки буфера и записи его в файл;

Получается что очередь нам на самом деле не нужна, если будет простой способ переключения буферов. Получится два рабочих потока и один управляющий:
* Чтения данных и записи в буфер;
* Сортировка буфера и запись его в файл;
* Управляющий поток, который будет запускать сортировку, сохранение и давать новый буфер;

Потом можно поиграть с количеством буферов.

RecordBuffer<T> {
  T[] storage;
  int index;
  boolean isFull();
  void add(T record);
  void sortIfComparable();
  void save();
}

ControllerThread implements Runnable {
  RecordBuffer issued; // Выданный
  RecordBuffer saving; // Сохраняющийся

  void saveLast() {
    // Не давать, если сортировка не закончена, т.е. не больше двух. 
    if (null != saving) {
      while (null != saving) {
        // Ждём…
      }
    }
    saving = issued;
  }

  RecordBuffer getRecordBuffer() { // Запустить сортировку того, который был выдан ранее
    saveLast();
    issued = new RecordBuffer();
    return issued;
  }
  
  void run() {
    while (running) {
      if (null != saving) {
        lock;
        saving.sortIfComparable();
        saving.save();
        saving = null;
      }
    }
  }
}

В принципе получается, что нужно всё-таки два потока. Сортировочно-записывающий может сам выдвать новые буфера записи.

В промежуточных файлах можно просто ObjectStream, чтобы не тратить время на разбор записей из файла.

В принципе явный пример — это http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Exchanger.html — там один заполнитель, другой опустошитель.


